# 源码漏洞扫描系统 MVP 规格说明书

## 1. 核心智能体选择 🤖

### 1.1 确认的MVP智能体

**✅ 项目经理智能体 (Project Manager Agent)**
- **MVP核心职责**: 
  - 接收并验证API扫描请求
  - 初始化扫描任务并生成唯一任务ID
  - 调度代码分析智能体执行扫描
  - 监控扫描进度和状态管理
  - 返回最终扫描结果

**✅ 代码分析智能体 (Code Analysis Agent)**
- **MVP核心职责**:
  - 基于Git URL克隆代码仓库
  - 自动识别项目主要编程语言
  - 调用单一SAST工具执行扫描
  - 收集并标准化扫描结果
  - 向项目经理智能体报告扫描状态

### 1.2 智能体简化设计原则

- **单一职责**: 每个智能体专注核心功能，避免复杂决策逻辑
- **同步通信**: MVP阶段使用简单的同步调用，不引入消息队列
- **本地执行**: 所有组件在单一环境中运行，简化部署

## 2. 核心用户故事 (User Stories) 📖

### 2.1 用户故事 #1: 触发扫描
```
作为一名开发者
我希望通过一个简单的REST API请求
提供Git仓库地址和分支信息
来启动一次源码漏洞扫描
以便及时发现代码中的安全问题

验收标准:
- API端点: POST /api/v1/scan
- 必需参数: repository_url, branch
- 可选参数: scan_id (用户自定义任务标识)
- 返回: 任务ID和初始状态
- 响应时间: < 5秒
```

### 2.2 用户故事 #2: 任务执行
```
作为系统管理员
我希望系统接收到扫描请求后
代码分析智能体能够自动克隆指定的代码库
并处理常见的Git操作异常
以确保扫描任务能够稳定执行

验收标准:
- 支持公开的Git仓库克隆
- 支持指定分支的代码获取
- 处理网络异常、权限异常等常见错误
- 克隆超时设置: 300秒
- 克隆完成后验证代码目录结构
```

### 2.3 用户故事 #3: 基础扫描
```
作为安全工程师
我希望代码分析智能体能够调用预设的SAST工具
对克隆的代码进行安全扫描
并收集原始的扫描结果
以识别潜在的安全漏洞

验收标准:
- 集成Semgrep作为默认SAST工具
- 自动识别项目语言(Java, Python, JavaScript, Go)
- 使用对应语言的规则集进行扫描
- 扫描超时设置: 1800秒 (30分钟)
- 生成结构化的扫描结果
```

### 2.4 用户故事 #4: 结果获取
```
作为开发者
我希望扫描完成后
能够通过API查询扫描状态和结果
获得JSON格式的原始扫描数据
以便进行后续的漏洞分析

验收标准:
- API端点: GET /api/v1/scan/{task_id}/status
- API端点: GET /api/v1/scan/{task_id}/results
- 返回标准化的JSON格式结果
- 包含扫描状态、发现的问题列表、基本统计信息
- 支持结果数据的持久化存储
```

### 2.5 用户故事 #5: 错误处理
```
作为开发者
我希望当扫描过程出现错误时
能够获得清晰的错误信息和建议
以便快速定位和解决问题

验收标准:
- 标准化的错误响应格式
- 详细的错误代码和描述
- 常见错误的解决建议
- 错误日志记录和查询接口
```

## 3. 数据流转简化版 📊

### 3.1 MVP数据交换格式

```json
{
  "task_id": "scan_20240115_001",
  "timestamp": "2024-01-15T10:00:00Z",
  "status": "pending|running|completed|failed",
  "repository": {
    "url": "https://github.com/example/project.git",
    "branch": "main",
    "commit_sha": "abc123def456"
  },
  "project_info": {
    "languages": ["Java", "JavaScript"],
    "file_count": 245,
    "total_lines": 15420
  },
  "scan_results": {
    "scan_tool": "semgrep",
    "scan_duration": 120,
    "findings_count": 15,
    "findings": [
      {
        "rule_id": "java.lang.security.audit.sql-injection",
        "severity": "HIGH|MEDIUM|LOW",
        "message": "Potential SQL injection vulnerability",
        "file_path": "src/main/java/UserController.java",
        "line_number": 45,
        "code_snippet": "String query = \"SELECT * FROM users WHERE id = \" + userId;",
        "category": "security"
      }
    ]
  },
  "error": {
    "code": "SCAN_FAILED",
    "message": "详细错误描述",
    "details": "技术细节和建议"
  }
}
```

### 3.2 关键字段说明

| 字段 | 类型 | 必需 | 说明 |
|------|------|------|------|
| `task_id` | String | ✅ | 唯一任务标识符 |
| `status` | Enum | ✅ | 任务执行状态 |
| `repository.url` | String | ✅ | Git仓库地址 |
| `repository.branch` | String | ✅ | 目标分支 |
| `scan_results.findings` | Array | ✅ | 扫描发现的问题列表 |
| `error` | Object | ❌ | 错误信息(仅在失败时返回) |

## 4. "完成"的定义 (Definition of Done) ✅

### 4.1 功能完整性

- [ ] **API接口完整**: 所有定义的REST API端点已实现并测试通过
- [ ] **核心用户故事**: 所有5个核心用户故事的验收标准均已满足
- [ ] **端到端流程**: 完整的扫描流程(请求→克隆→扫描→结果返回)能够稳定运行
- [ ] **错误处理**: 常见异常场景都有适当的错误处理和用户友好的错误信息

### 4.2 质量标准

- [ ] **单元测试覆盖率**: 核心业务逻辑的单元测试覆盖率 ≥ 80%
- [ ] **集成测试**: 端到端集成测试用例覆盖所有主要场景
- [ ] **性能测试**: 单个扫描任务在标准项目(1000-5000行代码)上的执行时间 < 10分钟
- [ ] **稳定性测试**: 连续执行20次扫描任务，成功率 ≥ 95%

### 4.3 部署和文档

- [ ] **Docker化部署**: 提供完整的Docker compose配置，一键启动
- [ ] **API文档**: 使用OpenAPI/Swagger生成完整的API文档
- [ ] **用户手册**: 包含安装、配置、使用的完整说明文档
- [ ] **开发者文档**: 代码架构说明和贡献指南

### 4.4 代码质量

- [ ] **代码审查**: 所有代码都经过至少一轮代码审查
- [ ] **代码规范**: 遵循项目定义的代码规范和最佳实践
- [ ] **版本控制**: 所有代码提交到Git仓库，带有清晰的提交信息
- [ ] **CI/CD流水线**: 基础的持续集成流水线配置

## 5. 排除范围 ❌

### 5.1 明确不包含的功能

#### 5.1.1 高级智能体功能
- ❌ **漏洞验证与分类智能体**: 无误报分析、无漏洞去重、无CVSS评分
- ❌ **修复方案生成智能体**: 无修复建议、无代码生成、无修复验证
- ❌ **报告与通知智能体**: 无复杂报告、无邮件通知、无第三方集成

#### 5.1.2 高级扫描功能
- ❌ **多工具集成**: 只集成Semgrep，不包含SonarQube、CodeQL等其他工具
- ❌ **动态扫描(DAST)**: 不包含运行时安全测试
- ❌ **软件成分分析(SCA)**: 不包含依赖包漏洞扫描
- ❌ **增量扫描**: 只支持全量扫描，不支持基于Git diff的增量扫描

#### 5.1.3 企业级功能
- ❌ **用户认证与授权**: 无用户管理、无权限控制
- ❌ **Web界面**: 无仪表盘、无可视化报告、无用户界面
- ❌ **高可用性**: 无集群部署、无负载均衡、无故障转移
- ❌ **审计日志**: 无操作审计、无合规性检查

#### 5.1.4 高级通信机制
- ❌ **消息队列**: 不使用Kafka、RabbitMQ等消息中间件
- ❌ **分布式架构**: 所有组件在单一进程中运行
- ❌ **异步处理**: 使用同步调用，不包含复杂的异步任务管理

#### 5.1.5 机器学习功能
- ❌ **智能学习**: 无误报学习、无模式识别、无持续优化
- ❌ **LLM集成**: 不集成GPT、Claude等大语言模型
- ❌ **自动化决策**: 无智能优先级排序、无自动化风险评估

### 5.2 技术债务说明

MVP阶段的简化设计可能产生的技术债务：

1. **架构债务**: 单体架构需要在后续版本中重构为微服务
2. **扩展性债务**: 同步处理模式限制了并发能力
3. **数据存储债务**: 简单的文件存储需要升级为数据库
4. **监控债务**: 缺乏完整的日志和监控机制

## 6. MVP实施计划 📅

### 6.1 开发里程碑

**Sprint 1 (Week 1-2): 基础架构**
- 项目搭建和基础框架
- REST API框架搭建
- Docker化配置

**Sprint 2 (Week 3-4): 核心智能体**
- 项目经理智能体开发
- 代码分析智能体开发
- Git操作和Semgrep集成

**Sprint 3 (Week 5-6): 集成测试**
- 端到端流程测试
- 错误处理完善
- 性能优化

**Sprint 4 (Week 7-8): 文档和部署**
- API文档生成
- 用户手册编写
- 部署验证和交付

### 6.2 风险评估

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| Semgrep集成复杂度 | 中 | 高 | 提前进行技术验证 |
| Git操作异常处理 | 高 | 中 | 完善错误处理机制 |
| 性能不达标 | 中 | 中 | 设置合理的超时和资源限制 |
| 部署复杂度 | 低 | 中 | 使用Docker简化部署 |

## 7. 成功指标 📊

### 7.1 技术指标
- **可用性**: 系统正常运行时间 ≥ 99%
- **性能**: 单次扫描完成时间 < 10分钟
- **准确性**: 能够正确识别Semgrep支持的漏洞类型
- **稳定性**: 连续运行无内存泄漏和崩溃

### 7.2 用户体验指标
- **易用性**: 新用户5分钟内完成首次扫描
- **API响应性**: 99%的API请求响应时间 < 2秒
- **错误友好性**: 所有错误都有清晰的错误信息

这个MVP规格说明书为开发团队提供了清晰的目标和边界，确保在有限的时间和资源内交付一个可用的产品，并为后续迭代奠定良好基础。